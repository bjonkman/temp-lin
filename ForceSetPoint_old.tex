\documentclass[11pt]{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{tPreambule.tex}
\usepackage{fullpage}
% \usepackage[pass, showframe]{geometry}
\setlength{\itemsep}{-10em}

\newcommand{\question}[1]{{\color{red}{#1}}}
\begin{document}
\title{Development plan for the linearization about a rotational speed set-point in OpenFAST}
\author{E. Branlard, J.Jonkman}
\maketitle
% \tableofcontents 
% \newpage

\section*{Introduction}
This document describes the implementation of an algorithm to perform %close-loop
linearization about a rotational set-point in \textit{OpenFAST}. Currently, the user needs to manually adjust operating parameters until the desired rotational speed is reached and the linearization can be performed. This procedure is here automatized using a simple iterative algorithm. The algorithm presented adjusts one of the following operating parameter to reach the target rotational speed: the blade pitch angle, the generator torque or the neutral yaw position of the turbine. A proportional gain on the rotational speed error is used to adjust the parameters. To speed-up the convergence, the damping may be artificially increased in the iteration step. At the end of the iteration algorithm, the target rotational speed and a periodic operating point are reached. The linearization is then performed for one rotor revolution without the previously added damping.
The algorithm is such that it only involves modifications of the \textit{OpenFAST} glue-code and of \tt{ServoDyn}.


% \clearpage
\section{OpenFAST implementation}

\subsection{Basic workflow and changes to the code}
The basic workflow is listed below. More details follow in subsequent sections.
\begin{itemize}\tightlist
    \item New parameters are read from the input files (given in \autoref{sec:newinputs})
    \item If the parameter \tt{CalcSteady} is false, \textit{OpenFAST} the linearization process will happen as before (at LinTimes)
    \item 
      If \tt{CalcSteady} is true, \textit{OpenFAST} will iterate and update a controller parameter
      until the rotational speed matches the parameter \tt{RotSpeed} given in \textit{ElastoDyn}'s input file, and then perform the linearization at this periodic operating point.
%      to find the controller values required to get a periodic operating point before performing the linearization. 
%       A linearization will then proceed at this periodic operating point. 
     A different controller variable is adjusted in the iterative step based on the value of the parameter \tt{TrimCase}: the neutral yaw \tt{YawNeut}, the generator torque \tt{GenTrq} or the blade pitch \tt{BlPitch}. 
     The procedure follows the steps below.
%      The process is described below.
    \item After the initialization of \textit{ElastoDyn}, additional initialization inputs are passed to \textit{ServoDyn} for its initialization:  the glue-code inputs \tt{CalcSteady}, \tt{TrimCase} and \tt{TrimKom} and the reference rotational speed \tt{RotSpeedRef}. These initialization inputs will be used by \textit{ServoDyn} to adjust one of the controller parameter based on the current rotational speed error.
    \item \textit{ServoDyn} is initialized. The discrete-time state \tt{CtrlOffset} is added to the module to keep track of the controller parameter offset.
    \item The glue-code starts a special time stepping loop where a convergence criteria is checked upon after each revolution.  The time stepping loop has the following characteristics:
    \begin{itemize}\tightlist
    \item At each time step, \textit{ServoDyn} updates its controller offset state (\tt{CtrlOffset}) based on the proportional gain \tt{TrimKom} and the error in rotational speed. This offset is added to the controller commands of \textit{ServoDyn} and will hence have an influence on \tt{ElastoDyn}. 
    \item At each time step, the glue-code adds additional damping, via external forces, to the structure of the modules \textit{ElastoDyn} and \textit{BeamDyn}.
    \item At given azimuthal positions (defined by \tt{NAzimStep}), the glue-code computes the relative difference between the output vector of the current revolution and the previous revolution.
    \item When this difference is below the tolerance \tt{TrimTol} for all the reference azimuthal positions, the simulation has reached a periodic steady state, which also implies that the controller offset parameter has also converged and the rotational speed of the rotor matches the requested set-point. The time-stepping is stopped
    \end{itemize}
    \item  The linearization is performed for one rotor revolution at steps of \tt{NAzimStep}. The operating point is at the requested rotational speed and it uses the controller offset obtained by the iteration procedure above.
\end{itemize}


The following sections describe the changes needed to the code:
\begin{itemize}
    \item \autoref{sec:newinputs}: new input parameters to be added to the \textit{OpenFAST} glue-code
    \item \autoref{sec:gluecodeiterative}: iterative procedure of the glue-code to ensure a periodic steady state is reached
    \item \autoref{sec:damping}: glue-code procedure to increase the damping and accelerate the convergence
    \item \autoref{sec:changesservodyn}: changes to \textit{ServoDyn} to compute the controller parameter offset
\end{itemize}


\subsection{New glue code inputs}
\label{sec:newinputs}
The following input are added to the main \textit{OpenFAST} input file (\tt{.fst} file):
%     \fortran
% \begin{lstlisting}
% CalcSteady - Linearize about periodic operating point (flag)
% TrimCase   - Controller parameter to be trimmed {1=yaw; 2=torque; 3=pitch} [1,2,3] [unused if CalcSteady=False]}
% TrimTol    - Tolerance for the rotational speed convergence [>=0] [used only when ClacSteady=True]
% Lin_Kom    - Proportional gain for the rotational speed error (rad/(rad/s) or Nm/(rad/s)) [>0] [used only when CalcSteady=True]
% Twr_Kdmp   - Damping factor for the tower (N/(m/s)) [>=0] [used only when CalcSteady=True]
% Bld_Kdmp   - Damping factor for the blade (N/(m/s)) [>=0] [used only when CalcSteady=True]
% NAzimStep  - Number of equally-spaced azimuth steps in periodic linearized model (-) [>=1]
% \end{lstlisting}
\begin{itemize}\tightlist
    \item \tt{CalcSteady - Calculate a steady-state periodic operating point before linearization  (flag)}
    \item \tt{TrimCase   - Controller parameter to be trimmed \{1:yaw; 2:torque; 3:pitch\} [used only if CalcSteady=True]}
    \item \tt{TrimTol    - Tolerance for the rotational speed convergence [>0] [used only when CalcSteady=True] }
    \item \tt{TrimKom    - Proportional gain for the rotational speed error (rad/(rad/s) or Nm/(rad/s)) [>0] [used only when CalcSteady=True] }
    \item \tt{Twr\_Kdmp   - Damping factor for the tower (N/(m/s)) [>=0] [used only when CalcSteady=True] }
    \item \tt{Bld\_Kdmp  - Damping factor for the blade (N/(m/s)) [>=0] [used only when CalcSteady=True] }
    \item \tt{NAzimStep  - Number of equally-spaced azimuth steps in periodic linearized model (-) [>=1] }
\end{itemize}
\question{Do we want to adjust more damping values?}
Linearization inputs are read in \tt{Fast\_Subs.f90}, routine \tt{FAST\_ReadPrimaryFile} about line 2273. They are returned in the structure named \tt{p} or \tt{p\_FAST} of type \tt{FAST\_ParameterType}. The parameters above needs to be added to the \tt{FAST\_Registry.txt} file as \tt{FAST\_ParameterType}.
% \clearpage










\subsection{Main glue-code procedure}
\label{sec:gluecodeiterative}


\paragraph{Main program}
\begin{itemize}\tightlist
    \item If \tt{CalcSteady} is false, set \tt{Twr\_Kdmp} and \tt{Bld\_Kdmp} to $0$ and proceed as usual
    \item If \tt{CalcSteady} is true, follow the iterative procedure below
\end{itemize}


\paragraph{Iterative procedure}
% \paragraph{Notations} 
The subscript $p$ is used to refer to the \textit{previous} time step, the subscript $c$ is used for the \textit{current} time step, the subscript $0$ is used to refer to the target azimuthal positions.
% 
The azimuthal angle $\psi$ 
% and the rotor speed $\Omega$ 
at a given time step are taken from the outputs of \textit{ElastoDyn}: \tt{ED\%y\%LSSTipPxa}.
% and \tt{ED\%y\%RotSpeed} respectively.
% 
% 
% 
% \paragraph{Allocations} \ 
The following storage variables are used by the iterative algorithm:
\begin{table}[!h]\centering
\begin{tabular}{ccp{10cm}}
\textbf{Variable} & \textbf{Dimensions}& \textbf{Description}\\
\hline
$\v{\psi}_0$ & $1\times \tt{NAzimStep}$ & Target azimuthal positions $\v{\psi}_0$, indexed with the variable $j$ \\
$\v{y}_c$ & $1\times n_y$ & Output vector (from all modules) at current time step \\
$\v{y}_p$ & $1\times n_y$ & Output vector (from all modules) at previous time step \\
$\v{y}_0$ & $1\times n_y$ & Output vector interpolated at a target azimuthal position \\
$\m{Y}_0$ & $n_{y}\times \tt{NAzimStep}$ & Output vector at each target azimuthal position $\psi_y$ \\
$\v{\epsilon}_y$ & $1 \times \tt{NAzimStep}$ & Relative error in the output vector between two revolutions at the same target azimuthal position \\
\hline
\end{tabular}
\end{table}

The following steps make up the iterative procedure:
\begin{itemize}\tightlist
%     \item Allocate the matrix $\m{Y}_0$ of dimension $n_{y}\times \tt{NAzimStep}$ to store the output vector from all the modules at each target azimuthal position $\v{\psi}_0$, where $n_{y}$ is the number of outputs from all the modules. 
%     \item Allocate $\v{p}_p$, the vector of output from the previous time step, and set it to the current output vector.
% \item 
%     \begin{align}
%          \v{y}_p =\operatorname{NaN}(1,n_y)
%     \end{align}
    \item Initialize the number of full rotor revolutions and the index of target azimuthal positions:
        \begin{align}
            n_\text{rot} = 0
         , \qquad
         j = 1
%          , \qquad
%       \epsilon_\Omega=0
%          , \qquad
%          \psi_p = \psi_\text{init}
%               %\label{eq:}
        \end{align}
    \item Perform time stepping until $\tt{TMax}$ (the time loop will be stopped before $\tt{TMax}$ if the convergence criteria is met).
%       The output vector is stored for each target azimuthal position $\v{\psi}_0$. 
      For each time step:
        \begin{itemize}\tightlist
            \item Call the time step integration routine \tt{FAST\_Solution\_T}. This routine applies an increased damping (based on \tt{Twr\_Kdmp} and \tt{Bld\_Kdmp}, see \autoref{sec:damping}) and applies an offset to the controller variables (based on $\epsilon_\Omega$, see \autoref{sec:changesservodyn}).
            \item Store the current azimuthal angle and output vector: $\psi_{c}$ and $\v{y}_c$
%             \item Store the current output vector from all the modules $\v{y}_\text{c}$
            \item If $t=0$ (or first time step):
                \begin{itemize}\tightlist
%                     \item Set the reference rotor speed as $\Omega_\text{ref}=\Omega_c$
%                     \item If $\Omega_\text{ref}=0$, exit the trimming algorithm
                    \item Set the initial azimuthal position as $\psi_\text{init}=\psi_c$
                        The azimuthal angle is stored as a number in the interval $[0;\, 2\pi [$ ($2\pi$ excluded), i.e. $\psi_c=\operatorname{mod}(\psi, 2\pi)$, implemented as $\psi_c$=\tt{Zero2TwoPi($\psi$)}.
                    \item Set the vector of target azimuthal positions $\v{\psi}_0$ (also in $[0;\,2\pi[$):
                            \begin{align}
                                 k=1..\tt{NAzimStep}
                                 ,\quad
                                 \v{\psi}_0[k] = \operatorname{mod}(\psi_\text{init} +  (k-1) \Delta\psi, 2\pi), \quad \Delta\psi\eqdef \frac{2\pi}{\tt{NAzimStep}}
                            \end{align}

                    \item Set $\v{y}_p=\v{y}_c$ ans $\psi_p=\psi_c$
                \end{itemize}
%             \item Compute the error in rotor speed $\epsilon_\Omega$, the difference between the target speed and the current rotor speed:
%                 \begin{align}
%                     \epsilon_\Omega ={\Omega_c - \Omega_\text{ref}}
%                 \end{align}
%                 This error will be used at the next time step to correct the controller parameter

            \item If $(\psi_c -\psi_p) \geq \Delta\psi$, return an error: the rotor is spinning too fast, the time step or \tt{NazimStep} are too large

            \item If $\psi_c \geq \psi_0[j]$ 
                \begin{itemize}
                    \item Interpolate the output vector to the target azimuthal position $\psi_0[j]$ using the current output values $\v{y}_c$ and the previous ones $\v{y}_p$:
                        \begin{align}
                     \v{y}_0 = \v{y}_p + (\v{y}_c-\v{y}_p)\frac{\psi_0[j]-\psi_p}{\psi_c-\psi_p}   %\label{eq:}
                        \end{align}
                        Note: no special care needed since the angles are in $[0;\, 2\pi[$
                    \item If $n_\text{rot}>0$, compute the L2-norm of the relative error of the output vector at the azimuthal position $\psi_0[j]$ between the current revolution and the previous one:
                        \begin{align}
                            \epsilon_y^2[j] %=\rVert\boldsymbol{\epsilon_y}\lVert^2
                            = \sum_i \left(\frac{y_0[i]-Y_0[j,i]}{y_\text{ref}[i]}  \right)^2
    %                     ,\qquad \epsilon_{\dot{q}}^2 = \rVert (\boldsymbol{\dot{q}}-\boldsymbol{\dot{q}_0}). \boldsymbol{w}^t\lVert^2
                        \end{align}
                        Note: if the variable $y_0[i]$ is in radian or degree, the difference of the variable should be taken between $-\pi$ and $\pi$, implemented using \tt{MPi2Pi}. 
                    \item Store the interpolated value
                        \begin{align}
                            \m{Y}_0[:,j] = \v{y}_0
                        \end{align}
                    \item Increment $j$%: $j\leftarrow j+1$
                \end{itemize}

            \item Set the current values as previous values for the next time step
                \begin{align}
                   \psi_p \leftarrow \psi_c
                   ,\qquad
                   \v{y}_p \leftarrow \v{y}_c
                \end{align}

            \item If $j>\tt{NAzimStep}$: 
                    \begin{itemize}
                        \item Increment $n_\text{rot}$
                        \item Check convergence over all azimuthal positions: $\epsilon^2_y[k]<\tt{TrimTol}$ for all $k$
                        \item If converged, exit the time loop
                        \item Otherwise, set $j=1$ and continue the time stepping.
            \end{itemize}

    \end{itemize}
    \item If the time loop run up to \tt{TMax}, return an error, otherwise perform the linearization step below
\end{itemize}
\paragraph{Linearization}
\begin{itemize}
\item The values \tt{Twr\_Kdmp} and \tt{Bld\_Kdmp} are set to 0
% \item The controller offset is kept to its value $p_\text{off}$
\item The standard linearization procedure takes place
\end{itemize}




% --------------------------------------------------------------------------------}
% --- SERVODYN 
% --------------------------------------------------------------------------------{
\subsection{Changes in \textit{ServoDyn}}
\label{sec:changesservodyn}
In the updated implementation, \textit{ServoDyn} has the possibility to modify some of its outputs based on offset that is updated internally as a discrete state.

\paragraph{New registry types}
The inputs \tt{RotSpeedRef}, \tt{TrimCase}, \tt{TrimKom} are added: 
\fortran
\begin{lstlisting}
InitInputType	IntKi	TrimCase	-	-	-	"Controller parameter to be trimmed"	-
InitInputType	ReKi	TrimKom	-	-	-	"Proportional gain on rotational speed error"	-
InitInputType	ReKi	RotSpeedRef	-	-	-	"Reference rotational speed"	rad/s??
\end{lstlisting}
These inputs should also be added as \tt{ParameterType} in the registry file.
%          , \qquad
The discrete state \tt{CtrlOffset} (also noted $x_\text{off}$) is added: 
%       \epsilon_\Omega=0
\begin{lstlisting}
DiscreteStateType	ReKi	CtrlOffset	-	-	-	"Controller offset parameter"	-
\end{lstlisting}


\paragraph{Glue-code transfer before the init routine}
The controller trimming option of \textit{ServoDyn} requires additional parameters from the glue-code and \textit{ElastoDyn}. These parameters need to be transferred via the \tt{SrvD\_InitInputType} structure.
Currently, these transfer occur in the routine \tt{FAST\_InitializeAll} of \tt{FAST\_Subs.f90}. The following transfer is added: 
\fortran
\begin{lstlisting}
InitInData_SrvD%TrimCase    = p_FAST%TrimCase
InitInData_SrvD%TrimKom     = p_FAST%TrimKom
InitInData_SrvD%RotSpeedRef = ED%Output(1)%RotSpeed
\end{lstlisting}



\paragraph{Initialization routine \tt{Srvd\_Init}}
The added variables from \tt{InitInputType} are copied to the \tt{ParameterType} variables.
The state variable \tt{CtrlOffset} is initialized to 0.
If the parameter \tt{TrimKom} is not strictly positive, an error is thrown.


\paragraph{Update state routine \tt{Srvd\_UpdateDiscState}}
A simple proportional gain on the rotational speed error is used to correct the control parameters.
The error in rotor speed $\epsilon_\Omega$ is the difference between the target speed and the current rotor speed:
        \begin{align}
            \epsilon_\Omega ={\Omega_c - \Omega_\text{ref}}
        \end{align}
The current rotor speed is $\Omega_c=\tt{u\%RotSpeed}$.
        The offset on the controller variable is computed using 
        the speed error and a proportional gain $k_p>0$. The offset is computed as:
        \begin{align}
            x_\text{off} = x_\text{off} + s\, k_p\, \epsilon_\Omega \label{eq:xoffpitch}
        \end{align}
The variable $s$ above accounts for possible sign adjustments. 
The offset is such that it will converge to a constant value as $\epsilon_\Omega$ tends to 0.
When \tt{TrimCase}=1, $x_\text{off}$ is the yaw angle offset (in rad). 
When \tt{TrimCase}=2, $x_\text{off}$ is the generator torque offset (in N). 
When \tt{TrimCase}=3, $x_\text{off}$ is the pitch angle offset (in rad). 
% The offset 
For the pitch and generator torque, $s=1$. Indeed, when the rotational speed is faster than $\Omega_\text{ref}$ ($\epsilon_\Omega>0)$, the  pitch or generator torque needs to be increased to lower the rotational speed. The opposite holds when the rotor spins slower than $\Omega_\text{ref}$.
%     For the pitch and 
% The main control variable for the yaw is the yaw moment. The yaw moment is computed as $-k_\text{yaw} (\theta_\text{ED} - \theta_0)$.
On the other hand, when $\epsilon_\Omega>0$, the yaw angle needs to be increased if the yaw angle is positive, or decreased if this angle is negative, in order to decrease the rotational speed. For this case, $s=\operatorname{sign}( \theta_{\text{yaw},0}+x_\text{off})$, where $\theta_{\text{yaw},0}$ is the neutral yaw angle defined by \tt{p\%YawNeut}.
Another subtlety arises for the yaw case, since the main variable of \textit{ServoDyn} is actually the yaw moment. Yet, it is more convenient to manipulate an offset on the yaw angle since the offset sign depends on the yaw angle. 
This issue will be addressed in the next paragraph.
The update of the discrete state is implemented as follows:
\begin{lstlisting}
if ((TrimCase==2).or.(TrimCase==3)) then
    xd%CtrlOffset += (u\%RotSpeed - p%RotSpeedRef) * TrimKom 
else if ((TrimCase==3) then
    xd%CtrlOffset += (u%RotSpeed - p%RotSpeedRef) * sign(TrimKom, p%YawNeutr + xd%CtrlOffset)
else
    xd%CtrlOffset = 0
endif
\end{lstlisting}




\paragraph{Output routine \tt{SrvD\_CalcOutput}}
The output variables of \textit{ServoDyn} are directly modified using the offset \tt{CtrlOffset}.
As mentioned in the previous paragraph, in the yaw case, the main variable outputted by \textit{ServoDyn} is the yaw moment and not the yaw angle. The part of the yaw moment that depends on the yaw angle is computed as:
\begin{align}
    Q_\text{yaw}= - k_\text{yaw} ( \theta_\text{yaw,ED} - \theta_{\text{yaw},0})
\end{align}
Hence, if $\theta_{\text{yaw},0}$ is replaced by  $\theta_{\text{yaw},0}+x_\text{off}$, it is seen that the yaw moment is given the offset $k_\text{yaw} x_\text{off}$.
% 
% 
For the implementation, the control outputs are trimmed just after their computation within the  \tt{SrvD\_CalcOutput} routine, that is after calling \tt{Pitch\_CalcOutput}, \tt{Torque\_CalcOutput} and \tt{Yaw\_CalcOutput}, as follows:
\begin{lstlisting}
if (TrimCase==1) then
    y%YawMom     = y%YawMom      + xd%CtrlOffset * p%YawSpr
else if (TrimCase==2)
    y%GenTrq     = y%GenTrq      + xd%CtrlOffset
else if (TrimCase==3)
    y%BlPitchCom = y%BlPitchCom  + xd%CtrlOffset
else
    ! do nothing
endif
\end{lstlisting}
By doing the update in \tt{Svrd\_CalcOutput}, it is ensured that the operating point will be about the proper conditions. Indeed, in \tt{Svrd\_GetOP}, the operating point variables are set from the outputs directly:
\begin{lstlisting}
y_op(Indx_Y_BlPitchCom) = y%BlPitchCom
y_op(Indx_Y_YawMom)     = y%YawMom 
y_op(Indx_Y_GenTrq)     = y%GenTrq
\end{lstlisting}
It is important to note that the routines \tt{CalculateStandardYaw} and \tt{CalcuateTorque} returns values without offset. These routines are for instance called by  \tt{Yaw\_UpdateStates}  and \tt{Torque\_UpdateStates}.
% \weird{Yaw\_CalcOutput, calls \tt{CalculateStandardYaw}, also called by \tt{Yaw\_UpdateStates}}
% \weird{Torque\_CalcOutput, calls \tt{CalcuateTorque}, also called by \tt{Torque\_UpdateStates}}

\paragraph{Linearization routine \tt{SrvD\_JacobianPInput}}
This routine uses a generator torque which does not have an offset. 
It may require the following modification:
\begin{lstlisting}
if (TrimCase==2)
    GenTrq     = GenTrq      + xd%CtrlOffset
endif
\end{lstlisting}


% 
% 
% 
% 
% 
% Depending on \tt{TrimCase}, the variable $p$ is either the yaw degree of freedom, the generator torque or the pitch angle. 
% 






% --------------------------------------------------------------------------------}
% --- DAMPING 
% --------------------------------------------------------------------------------{
\subsection{Additional glue-code procedure to increase the damping}


\label{sec:damping}
Artificial damping forces are added to the external forces applied on the structure.
For now, the extra damping is only applied to \textit{ElastoDyn} and \textit{BeamDyn}.
% 
The extra damping force is set to be proportional to the velocity of each node of the structure. The proportionality constants \tt{Twr\_Kdmp} and \tt{Bld\_Kdmp} are used respectively for nodes on the tower or the blade. 
% For instance, the $j^{th}$ node of blade $i_B$ in \textit{ElastoDyn} is found in the following mesh $\text{ED}\%u\%\text{BladeLn2Mesh}[i_B]$.
% Writing this node $u_\text{B}[j]$, the additional forces is computed as:
% 
% This force is computed at each node of \textit{ElastoDyn}, based on the velocities of this node:
% Writing
% \text{ED}\%y\%Mesh
In general, the force $\v{F}$ on a given node of velocity $\v{v}$ is updated as follows:
\begin{align}
    \v{F} \leftarrow  \v{F}  -  k_\text{dmp}\  \v{v}
\end{align}
The forces are usually found as inputs of a module while the kinematics are found in the outputs. 
% 
The additional damping forces can be implemented in the procedure \tt{ED\_InputSolve} of the glue-code.
% % 
For \textit{ElastoDyn}, the update of the forces 
\begin{lstlisting}
u%TowerPtLoads   %Force(1:3,J) -= Twr_Kdmp*y%TowerLn2Mesh   %TranslationVel(1:3,J)
u%BladePtLoads(K)%Force(1:3,J) -= Bld_Kdmp*y%BladeLn2Mesh(K)%TranslationVel(1:3,J)
\end{lstlisting}
where $K$ is the blade number and $J$ is the node index (along the tower or blade, looping til \tt{NNodes}), $u$ and $y$ are the module input and outputs.
For \textit{BeamDyn}, the additional damping is added as follows:
\begin{lstlisting}
u(k)%PointLoad%Force(1:3,J) -= Bld_Kdmp*y(k)%BladeModtion%TranslationVel(1:3,J)
\end{lstlisting}



% Similar equations are applied for all the other meshes of \textit{ElastoDyn} and \textit{BeamDyn} module.
% %     \text{BD}\%u\%F = \text{BD}\%y\%F -  \epsilon_C\  \text{BD}\%y\%v
% \question{We need to make sure we do not damp some of the wanted motions (rotor's speed).}
% 
% in \tt{ED\_InputSolve}
% \begin{lstlisting}
% !p_FAST%CompAero = Module_None
% DO K = 1,SIZE(u_ED%BladePtLoads,1) ! Loop through all blades (p_ED%NumBl)
%   CALL Transfer_Line2_to_Point( y_AD%BladeLoad(k), u_ED%BladePtLoads(k), MeshMapData%AD_L_2_BDED_B(k), ErrStat2, ErrMsg2, u_AD%BladeMotion(k), y_ED%BladeLn2Mesh(k) )
%   ! OR
%   u_ED%BladePtLoads(K)%Force  = 0.0_ReKi
%   u_ED%BladePtLoads(K)%Moment = 0.0_ReKi
% END DO         
% \end{lstlisting}
% 
% % \begin{lstlisting}
% % ! connect AD mesh with BeamDyn
% % DO K=1,NumBl         
% % CALL MeshMapCreate( BD%y(k)%BldMotion, AD%Input(1)%BladeMotion(K), MeshMapData%BDED_L_2_AD_L_B(K), ErrStat2, ErrMsg2 )
% %    CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName//':BD_2_AD_BladeMotion('//TRIM(Num2LStr(K))//')' )
% % CALL MeshMapCreate( AD%y%BladeLoad(K), BD%Input(1,k)%DistrLoad,  MeshMapData%AD_L_2_BDED_B(K), ErrStat2, ErrMsg2 )
% %    CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName//':AD_2_BD_BladeLoad('//TRIM(Num2LStr(K))//')' )
% % END DO
% % \end{lstlisting}
% % 
% 
% 
% ElastoDyn Inputs Meshes
% \begin{lstlisting}
% BladePtLoads{:} "A mesh on each blade, containing aero loads"
% PlatformPtMesh  "A mesh at the platform reference (point Z), containing loads"
% TowerPtLoads    "Tower line2 mesh with tower loads"
% HubPtLoad       "A mesh at the teeter pin, containing loads on the hub"
% NacelleLoads    "From ServoDyn/TMD: loads on the nacelle."
% \end{lstlisting}
% 
% ElastoDyn Outputs Meshes:
% \begin{lstlisting}
% BladeLn2Mesh	{:}		"A mesh on each blade, kinematics of blade nodes"
% PlatformPtMesh	-		"Platform reference point kinematics"
% TowerLn2Mesh	-		"Tower line2 mesh kinematics"
% HubPtMotion14	-		"For AeroDyn v14: motions of the hub"
% HubPtMotion	-	-	"For AeroDyn and Lidar(InflowWind): motions of the hub"
% BladeRootMotion14		-	"For AeroDyn v14: kinematics the blade roots"
% BladeRootMotion	{:}		"For AeroDyn/BeamDyn:  kinematics the blade roots"
% RotorFurlMotion14		-	"For AeroDyn14: motions of the rotor furl point."
% NacelleMotion	-		"For AeroDyn14 & ServoDyn/TMD: motions of the nacelle."
% TowerBaseMotion14		-	"For AeroDyn 14: motions of the tower base"
% \end{lstlisting}
% 
% 
% 
% 
% 
% BeamDyn Outputs Meshes:
% \begin{lstlisting}
% RootMotion  "contains motion" -
% PointLoad   "Applied point forces along beam axis" -
% DistrLoad   "Applied distributed forces along beam axis" -
% HubMotion   "motion (orientation) at the hub" -
% \end{lstlisting}
% 
% BeamDyn Outputs Meshes:
% \begin{lstlisting}
% ReactionForce  "contains force and moments" -
% BldMotion      "Motion (disp,rot,vel, acc) along beam axis" -
% \end{lstlisting}
% 




% --------------------------------------------------------------------------------}
% ---  
% --------------------------------------------------------------------------------{



% \paragraph{Step 1 - Store outputs for one rotor revolution at \tt{NAzimStep} azimuthal positions}
% \begin{itemize}\tightlist
% 
%     \item Set the vector of azimuthal positions $\v{\psi}_0$ of dimension $1\times \tt{NAzimStep}$
%         \begin{align}
%              j=1..\tt{NAzimStep}
%              ,\qquad
%          \v{\psi}_0[j] = \psi_\text{init} +  (j-1) \Delta\psi + \Delta\psi/2, \qquad \Delta\psi\eqdef \frac{2\pi}{\tt{NAzimStep}}
%         \end{align}
%     \item Allocate the matrix $\m{Y}_0$ of dimension $n_{y}\times \tt{NAzimStep}$ to store the output vector from all the modules at each target azimuthal position $\v{\psi}_0$, where $n_{y}$ is the number of outputs from all the modules
% 
%     \item Initialize the following variables:
%         \begin{align}
%          j = 1
%          , \qquad
%          \psi_p = \psi_\text{init}
%          , \qquad
%          \v{y}_p =\operatorname{NaN}(1,n_y)
%               %\label{eq:}
%         \end{align}
%       The subscript $p$ refers to the previous time step, the subscript $c$ will be used for the current time step.
%   \item Perform time stepping for one rotor revolution. The output vector is stored for each target azimuthal position $\v{\psi}_0$. For each time step:
%         \begin{itemize}\tightlist
%             \item Call \tt{FAST\_Solution\_T}
%             \item If $t=0$, store the current rotor speed as the reference one: $\Omega_0$
%             \item Store the current azimuthal angle $\psi_{c}$ 
%             \item Store the current output vector from all the modules $\v{y}_\text{c}$
%             \item If $(\psi_c -\psi_p)>\Delta\psi/2$, return an error: the rotor is spinning too fast, the time step is too large
%             \item If $\psi_c \geq \psi_0[j]$, interpolate the output vector to the target azimuthal position $\psi_0[j]$ using the current output values and the previous ones:
%                 \begin{align}
%                     \v{y}_0 = \v{y}_p + (\v{y}_c-\v{y}_p)\frac{\psi_0[j]-\psi_p}{\psi_c-\psi_p}  %\label{eq:}
%                 \end{align}
%                 Store the interpolated value
%                 \begin{align}
%                     \m{Y}_0[:,j] = \v{y}_0
%                 \end{align}
%                 Increment $j$ %, $j\leftarrow j+1$
% %             \begin{align}
% %                 \v{y}_0[n] = \v{y}(\psi_0[t_n])
% %                   %\label{eq:}
% %             \end{align}
%             \item Set the current values as previous values for the next time step
%                 \begin{align}
%                    \psi_p \leftarrow \psi_c
%                    ,\qquad
%                    \v{y}_p \leftarrow \v{y}_c
%                 \end{align}
%             \item if $j>\tt{NAzimStep}$ exit the loop
%     \end{itemize}
% \end{itemize}
% 
% \paragraph{Step 2 - iterate to a constant rotational speed}
% \begin{itemize}
%     \item From this point, the glue code will enforce a controller offset $p_\text{off}$ to the trimmed controller parameter, and an external damping force will be added to help the convergence of the system.
% \item Initialize the controller offset $p_\text{off}$ to zero.
%     \item Start an iteration loop
%         \begin{itemize} \tightlist
%             \item Compute a reference value for each of the index of the output vector, based on the maximum and minimum values taken over one rotor revolution.
%                 \begin{align}
%                     y_{\text{ref}}[i] = \max(Y_0[:,i]) - \min(Y_0[:,i])
%                 \quad\text{if }\
%                 y_\text{ref}[i]>10^{-6}
%                 ,\quad\text{else }\
%                 y_\text{ref}[i]=1
%                 \end{align}
% 
%             \item Initialize the following variables:
%                 \begin{align}
%                  j = 1
%                  , \qquad
%                  \psi_p = \psi_\text{init}
%                  , \qquad
%                  \v{y}_p =\operatorname{NaN}(1,n_y)
%                       %\label{eq:}
%                 \end{align}
% 
%             \item Perform time stepping for one rotor revolution, where for each time step:
%                 \begin{itemize} \tightlist
%                     \item Call \tt{FAST\_Solution\_T} (Note: the damping is increased via the variable $\epsilon_C$ and the trimmed controller value will receive the offset $p_\text{off}$)
%                     \item Store $\Omega$, $\psi_c$, $\v{y}_c$
% %                     \item If $(\psi_c -\psi_p)>\Delta\psi/2$, return an error: the rotor is spinning too fast, the time step is too large
%                     \item If $\psi_c \geq \psi_0[j]$, interpolate the output vector to the target azimuthal position $\psi_0[j]$ using the current output values and the previous ones:
%                         \begin{align}
%                             \v{y}_0 = \v{y}_p + (\v{y}_c-\v{y}_p)\frac{\psi_0[j]-\psi_p}{\psi_c-\psi_p}  %\label{eq:}
%                         \end{align}
% 
% %                     \item Interpolate the previous output vector $y_0$ to the current value of $\psi$: $\v{y}_{p}=\operatorname{interp}(\psi_0,\v{y}_0,\psi)$ 
%                         Compute the L2-norm of the relative error of the output vector at the azimuthal position $\psi_0[j]$ between the current revolution and the previous one:
%                 \begin{align}
%                     \epsilon_y^2[j] %=\rVert\boldsymbol{\epsilon_y}\lVert^2
%                     = \sum_i \left(\frac{y_0[i]-Y_0[j,i]}{y_\text{ref}[i]}  \right)^2
% %                     ,\qquad \epsilon_{\dot{q}}^2 = \rVert (\boldsymbol{\dot{q}}-\boldsymbol{\dot{q}_0}). \boldsymbol{w}^t\lVert^2
%                 \end{align}
%                 Note: if the variable $y_0[i]$ is in radian or degree, the difference of the variable should be taken modulo $2\pi$. \\
% %             \item 
% %             \item Update damping values (\(C\)), using a stiffness proportional
% %                 damping scaled by the ,
% %                 \[ C_\text{new} = C_\text{start} + k_C \epsilon_{\dot{q}}^2 K\]
% %             \end{itemize}
% 
%             Store the interpolated value
%             \begin{align}
%                 \m{Y}_0[:,j] = \v{y}_0
%             \end{align}
%             Increment $j$%, $j\leftarrow j+1$
% 
%         \item     Compute the error in rotor speed \(\epsilon_\Omega\): the difference between the target speed and the current rotor speed
%                 \begin{align}
%                      \epsilon_\Omega ={\Omega - \Omega_0}
%                 \end{align}
%                 This error is used at each time step to correct the controller parameter
% %             \item 
% %                 The offset on the controller variable is incremented using
% %                 the speed error and a proportional gain $k_p$.
% %                 \begin{align}
% %                     p_\text{off} = p_\text{off} + k_p \epsilon_\Omega %\label{eq:}
% %                 \end{align}
% %                 This offset will be passed to the routine \tt{SD2ED} on the next time step
% 
% 
%         \item Set the current values as previous values for the next time step
%             \begin{align}
%                \psi_p \leftarrow \psi_c
%                ,\qquad
%                \v{y}_p \leftarrow \v{y}_c
%             \end{align}
% 
%         \item If $j>\tt{NAzimStep}$:  \\
%             Exit the iteration loop if $\epsilon^2[j]<\tt{TrimTol}$ for all $j$ (i.e. the output vector has converged for all azimuthal positions). Otherwise, set $j=1$ and continue the time stepping.
% 
% %             \item If $\epsilon_y^2$  is below a tolerance value \tt{Tol} exit the iteration loop
%         \end{itemize}
% %     \item Replace $\v{y}_0$ with the values of $\v{y}_1$, and $\psi_0$ with $\psi_1$: 
% %         \begin{align}
% %         \v{y}_0\leftarrow \v{y}_1
% %         ,\qquad
% %         \psi_0\leftarrow \psi_1
%               %\label{eq:}
% %         \end{align}
%     \item Continue to a next iteration unless the maximum number of iteration is exceeded
% \end{itemize}
% \end{itemize}
% 
% \paragraph{Step 2 - perform linearization}
% \begin{itemize}
% \item The values \tt{Twr\_Kdmp} and \tt{Bld\_Kdmp} are set to 0
% \item The controller off set is kept to its value $p_\text{off}$
% \item The linearization takes place
% \end{itemize}
% 
% 
% 
% 



\newpage
\appendix

\section{Input/output workflow of the controller parameters when linearization is on}
\begin{itemize}
    \item Yaw: ServoDyn returns the Yaw moment \tt{y\%YawMom}. 
        When linearization is enabled, \tt{YCMode=0}, and the routine \tt{CalcStandardYaw} returns the parameters \tt{p\%YawNeut}, hence \tt{YawPosCom}=\tt{YawNeut}. 
        The current nacelle yaw is provided as input (\tt{u\%Yaw}). It is first initialized to \tt{YawNeut}. It is used to set the operating point and in the moment calculation:
        \begin{align}
            \tt{YawMom} = k_\text{yaw} ( \tt{u\%Yaw} - \tt{YawPosCom} )
        \end{align}
        The input \tt{u\%YawAngle} is not used.
        The operating point \tt{y\_op} is set using \tt{y\%YawMom}.
        The operating point \tt{u\_op} is set using \tt{u\%Yaw}.
    \item Pitch: ServoDyn returns the pitch command \tt{y\%BlPitchCom}.
        When linearization is on, \tt{PCMode=0}, and then \tt{y\%BlPitchCom} is first set to \tt{p\%BlPitchInit}, but then the pitch maneuver overrides it. 
        The pitch maneuver is initialized with \tt{u\%BlPitch}.
        Apart from this initialization the input \tt{u\%BlPitch} is not used.
        The operating point \tt{y\_op} is set using the pitch command \tt{y\%BlPitchCom}.
    \item Generator Torque: ServoDyn returns \tt{y\%GenTrq}. 
        When linearization is on, \tt{VSCtrl} is 0 or 1, and the \tt{GenModel} is 1 or 2. 
        A non-zero generator torque is returned (based e.g. on the HSS speed, or the controller region) as long as the generator is online.
        The operating point is set using \tt{y\%GenTrq}.
\end{itemize}





\section{Workflow in FAST7}\label{old-workflow}
The computation is done in \tt{Fast\_lin.f90} within the routine \tt{CalcSteady}.
The workflow is as follows:

\begin{itemize}\tightlist
    \item Assign weights \(\boldsymbol{w}\) (\tt{QWeight},
        \tt{QDWeight}) for each DOF to ensure that each of them have a
        comparable contribution to the norm. For now, same weights for
        positions and speeds. \textbf{New: evaluate this on first iteration
        based on range of values - (max-min)}
    \item Store damping values\\
        \textbf{New: get the part of the system that has damping?}
    \item Save wind speed, as a safety measure to detect if windspeed is unsteady (in that case abort)
    \item Iteration loop
        \begin{itemize} \tightlist
            \item Save DOF position and velocities: \(\boldsymbol{q}\)
                (\tt{QStart}), \(\boldsymbol{\dot{q}}\) (\tt{QDStart})
            \item Start time stepping for one rotor revolution \textbf{Note: currently
                    \tt{NStep} is a constant, so the number of time steps is always
                    the same, and the loop is not based on azimuthal position. Probably
                fair and convenient also when \(\Omega=0\)}

                \begin{itemize} \tightlist
                    \item Call \tt{Solver}
                    \item Increase time step
                \end{itemize}
            \item Compute L2-norm in positions and speeds, \tt{AbsQNorm} and
                \tt{AbsQDNorm}, scaled by weights:
                \[\epsilon_q^2 = \rVert (\boldsymbol{q}-\boldsymbol{q_0}). \boldsymbol{w}^t\lVert^2 = \sum_i \left[(q(i)-q_0(i)) w(i) \right]^2
                    ,\qquad \epsilon_{\dot{q}}^2 = \rVert (\boldsymbol{\dot{q}}-\boldsymbol{\dot{q}_0}). \boldsymbol{w}^t\lVert^2
                \] \textbf{Note: special handling required for azimuth due to
                2pi-modulo}
            \item Compute the error in rotor speed \(\epsilon_\Omega\)
                (\tt{SpeedErr}): the difference between the target speed and the
                average rotor speed over the simulated period (computed during the
                loop above)
                \begin{align}
                    \epsilon_\Omega = \frac{\overline{\Omega} - \Omega_0}{\Omega_0}
                \end{align}
            \item Based on the \tt{TrimCase}, adjust the yaw DOF (either
                \tt{YawNeut} or the proper DOF in \tt{Q}) or the generator
                torque \tt{GenTrq} or the blade pitch \tt{BlPitch}, using
                the speed error and a proportional gain:
                \[ p_\text{new} = p_\text{old} + k_p \epsilon_\Omega\]
            \item Update damping values (\(C\)), using a stiffness proportional
                damping scaled by the ,
                \[ C_\text{new} = C_\text{start} + k_C \epsilon_{\dot{q}}^2 K\]
        \end{itemize}
\end{itemize}

\subsection{FAST 7 inputs}
\begin{itemize}\tightlist
    \item \tt{CalcStdy} This flag determines whether a periodic steady state solution is computed before linearizing the
model. If False, the next three inputs are ignored and the linearization occurs about the initial
conditions specified in FAST’s primary input file. That is, when CalcStdy is False, the operating
point is set to the condition in which all displacements, velocities, and accelerations are zero,
except those specified with nonzero initial conditions (for instance, the azimuth DOF will
increment at a constant rate if and when the rotor is spinning). If CalcStdy is True and
RotSpeed is nonzero, FAST integrates in time until a periodic steady state solution is reached.
The method of solution is determined by the next input, TrimCase. FAST is then linearized
about this periodic operating point. If CalcStdy is True and RotSpeed is zero, FAST will
disable GenDOF (if previously enabled) and integrate in time until a static equilibrium position is
found. FAST is then linearized about this position. The accuracy of the steady state solution is
determined through input convergence tolerances DispTol and VelTol (see below). This input is
not used in the FAST-to-ADAMS preprocessor. (flag)

\item \tt{TrimCase} This switch determines, for a variable speed machine, which control input to trim in order to reach
the desired azimuth-averaged rotor speed indicated through input RotSpeed (which is also the
initial rotor speed). 
 Setting it to 1 causes FAST to trim nacelle yaw command (demand) angle,
while maintaining constant rotor collective blade pitch (indicated by inputs BlPitch i ), to reach the
desired azimuth-averaged rotor speed. With yaw DOF enabled (YawDOF = True), the nacelle
yaw command is the neutral yaw angle, YawNeut, which is passed through FAST’s built-in,
second-order actuator model. With yaw DOF disabled (YawDOF = False), the nacelle yaw
command is the actual nacelle yaw angle. 

Setting TrimCase to 2 causes FAST to trim electrical
generator torque, while maintaining constant rotor collective blade pitch (indicated by inputs
BlPitch i ), to reach the desired azimuth-averaged rotor speed (i.e., Region 2 trim). 

Setting TrimCase to 3 causes FAST to trim rotor collective blade pitch to reach the desired azimuth-
averaged rotor speed (i.e., Region 3 trim). In this case, the initial “guess” blade pitch angles are
given by BlPitch i and the electrical generator torque is determined by the torque-speed
relationship indicated by inputs VSContrl or GenModel. For typical Region 3 trim, collective
pitch can be trimmed while maintaining a constant generator torque by setting TrimCase to 3,
VSContrl to 1, VS\_RtTq to the desired constant generator torque, and VS\_RtGnSp,
VS\_Rgn2K, and VS\_SlPc to 9999.9E-9 (very small don’t cares > 0.0). Input parameter
TrimCase is ignored when either CalcStdy or GenDOF is False. For a constant speed machine,
GenDOF should be set to False when linearizing FAST, in which case, input TrimCase is
ignored. Using values other than 1, 2, or 3 will cause FAST to abort. This input is not used in the
FAST-to-ADAMS preprocessor. (switch)


\item \tt{DispTol} This is the convergence tolerance for the 2-norm of angular displacements in the calculation of
periodic steady state solution. The steady state solution is found when this tolerance and VelTol
are both met. The smaller the number, the tighter the tolerance is. This input is ignored if
CalcStdy is False. This input is not used in the FAST-to-ADAMS preprocessor. (rad)

\item \tt{VelTol} This is the convergence tolerance for the 2-norm of angular velocities in the calculation of the
periodic steady state solution. The steady state solution is found when this tolerance and DispTol
are both met. The smaller the number, the tighter the tolerance is. This input is ignored if
CalcStdy is False. This input is not used in the FAST-to-ADAMS preprocessor. (rad/s)
FAST Users Guide 91 Last updated on August 12, 2005 for version 6.0
Table 15. Linearization Control-Input-File Parameters (concluded).


% Model Linearization

\item \tt{NAzimStep} This is the number of equally spaced rotor azimuth steps in the output periodic linearized model.
The first rotor azimuth location is always the initial azimuth position indicated by inputs Azimuth
and AzimB1Up. The subsequent azimuth steps increment in the direction of rotation. If
RotSpeed is zero, FAST will override NAzimStep and only linearize the model about the initial
azimuth position (as if NAzimStep was set to 1). This input is not used in the FAST-to-ADAMS
preprocessor. (-)

\item \tt{MdlOrder} This is the order of the output linearized model. A setting of 1 causes FAST to output the first-
order representation of the linearized model. A setting of 2 causes FAST to output the second-
order representation of the linearized model. Using values other than 1 or 2 will cause FAST to
abort. This input is not used in the FAST-to-ADAMS preprocessor. (-)
\end{itemize}

% 

% \clearpage








\section{Relevant portions of code}
\fortran
\begin{itemize}
    \item Time stepping: \tt{Fast\_Prog.f90}, around line 100 
\begin{lstlisting}
DO n_t_global = Restart_step, Turbine(1)%p_FAST%n_TMax_m1 
  ! this takes data from n_t_global and gets values at n_t_global + 1
  DO i_turb = 1,NumTurbines
     CALL FAST_Solution_T( t_initial, n_t_global, Turbine(i_turb), ErrStat, ErrMsg )
 \end{lstlisting}

\item Linearization inputs are read in \tt{Fast\_Subs.f90} routine \tt{FAST\_ReadPrimaryFile} about line 2273

\begin{lstlisting}
! Linearize - Linearization analysis (flag)
CALL ReadVar( UnIn, InputFile, p%Linearize, "Linearize", "Linearization analysis (flag)", ErrStat2, ErrMsg2, UnEc)
CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
if ( ErrStat >= AbortErrLev ) then
   call cleanup()
   RETURN        
end if      
\end{lstlisting}

\item Copy of states, \tt{Fast\_Subs.f90}, routine \tt{FAST\_Solution}, around line 4400
\begin{lstlisting}
!! STATE_CURR values of x, xd, z, and OtherSt contain values at m_FAST%t_global;
!! STATE_PRED values contain values at t_global_next.
! ElastoDyn: copy final predictions to actual states
CALL ED_CopyContState   (ED%x( STATE_PRED), ED%x( STATE_CURR), MESH_UPDATECOPY, Errstat2, ErrMsg2)
  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
CALL ED_CopyDiscState   (ED%xd(STATE_PRED), ED%xd(STATE_CURR), MESH_UPDATECOPY, Errstat2, ErrMsg2)  
  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
CALL ED_CopyConstrState (ED%z( STATE_PRED), ED%z( STATE_CURR), MESH_UPDATECOPY, Errstat2, ErrMsg2)      
  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
CALL ED_CopyOtherState (ED%OtherSt( STATE_PRED), ED%OtherSt( STATE_CURR), MESH_UPDATECOPY, Errstat2, ErrMsg2)      
  CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
 \end{lstlisting}
      
\item  Elastodyn states and DOFs, e.g. \tt{ElastoDyn.f90}, around line 3600; DOF numbers are defined in \tt{ElastoDyn\_IO.f90}
\begin{lstlisting}
   x%QT (DOF_GeAz) = REAL(InputFileData%Azimuth, R8Ki) - p%AzimB1Up - REAL(Piby2_D, R8Ki)
   x%QDT(DOF_GeAz) = p%RotSpeed                                               ! Rotor speed in rad/sec.
   x%QT (DOF_Yaw) = InputFileData%NacYaw
   x%QDT(DOF_Yaw) = 0.0
 \end{lstlisting}
\item  Elastodyn outputs, e.g. \tt{ElastoDyn.f90}, around line 1727, routine \tt{ED\_CalcOutput}
\begin{lstlisting}
   y%Yaw      = x%QT( DOF_Yaw)
   y%YawRate  = x%QDT(DOF_Yaw)
   y%YawAngle = x%QT( DOF_Yaw) + x%QT(DOF_Y)  !crude approximation for yaw error... (without subtracting it from the wind direction)   
   y%BlPitch  = u%BlPitchCom !OtherState%BlPitch
   y%LSS_Spd  = x%QDT(DOF_GeAz)
   y%HSS_Spd  = ABS(p%GBRatio)*x%QDT(DOF_GeAz)
   y%RotSpeed = x%QDT(DOF_GeAz) + x%QDT(DOF_DrTr)
 \end{lstlisting}
 \item Damping ElastoDyn , routine \tt{FillAugMat}
\begin{lstlisting}
- p%CBF(K,1,1)*x%QDT(DOF_BF(K,1)) &
- p%CBF(K,1,2)*x%QDT(DOF_BF(K,2))
- p%CBF(K,2,1)*x%QDT(DOF_BF(K,1)) &
- p%CBF(K,2,2)*x%QDT(DOF_BF(K,2))
- p%CBE(K,1,1)*x%QDT(DOF_BE(K,1))
- p%CTFA(1,1)*x%QDT(DOF_TFA1) - p%CTFA(1,2)*x%QDT(DOF_TFA2)
- p%CTSS(1,1)*x%QDT(DOF_TSS1) - p%CTSS(1,2)*x%QDT(DOF_TSS2)
- p%CTFA(2,1)*x%QDT(DOF_TFA1) - p%CTFA(2,2)*x%QDT(DOF_TFA2)
- p%CTSS(2,1)*x%QDT(DOF_TSS1) - p%CTSS(2,2)*x%QDT(DOF_TSS2)
\end{lstlisting}
\item Damping for \tt{SubDyn}: \tt{p\%N2OmegaMJDamp}, for \tt{ExtPtfm}:  \tt{p\%Damp(I,J)}, for \tt{MoorDyn}: \tt{Line\%BA} \tt{Line\%Td(J,I)} \tt{Line\%B(3,I)}, for \tt{BeamDyn}: \tt{m\%DampG}, \tt{m\%DampG\_fd}


\item InputFile
\begin{lstlisting}
---------------------- LINEARIZATION -------------------------------------------
False Linearize - {Linearization analysis (flag)}
1   NLinTimes   - {Number of times to linearize (-)}
30, LinTimes    - {List of times at which to linearize (s)}
1   LinInputs   - {Inputs included in linearization (switch) {0=none; 1=standard; 2=all module inputs (debug)}}
1   LinOutputs  - {Outputs included in linearization (switch) {0=none; 1=from OutList(s); 2=all module outputs (debug)}}
False LinOutJac - {Include full Jacobians in linearization output (for debug) (flag) [unused if Linearize=False; used only if LinInputs=LinOutputs=2]}
False LinOutMod - {Write module-level linearization output files}
\end{lstlisting}

\end{itemize}







% The routine \tt{SD2ED} performs the following step:
% 
% This routine should now take \tt{TrimCase} and an offset $p_\text{off}$ in argument.
\begin{align}
    \text{ED}\%u\%p &= \text{SD}\%y\%p + p_\text{off}\\
    \text{ED}\%u\%p &= \text{SD}\%y\%p + k_\Omega \epsilon_\Omega
\end{align}


In \tt{ED\_InputSolve}:
\fortran
\begin{lstlisting}
u_ED%GenTrq     = y_SrvD%GenTrq      +  "__HACK HERE ? __"
u_ED%BlPitchCom = y_SrvD%BlPitchCom  +  "__HACK HERE ? __"
u_ED%YawMom     = y_SrvD%YawMom
\end{lstlisting}

In \tt{SrvD\_InputSolve}:
\begin{lstlisting}
u_SrvD%YawAngle  = y_ED%YawAngle !nacelle yaw plus platform yaw
u_SrvD%Yaw       = y_ED%Yaw   + "__HACK HERE ?__" !nacelle yaw
u_SrvD%BlPitch   = y_ED%BlPitch
u_SrvD%LSS_Spd   = y_ED%LSS_Spd
u_SrvD%HSS_Spd   = y_ED%HSS_Spd
\end{lstlisting}

\paragraph{Controller outputs}
Yaw calc output: 
\begin{lstlisting}
if (TrimCase==1) then
    p%YawNeut = p%YawNeut   + CtrlOffset ) 
    ! OR:
    p%YawMom = - p%YawSpr *( u%Yaw     - YawPosCom  + CtrlOffset ) &   
               - p%YawDamp*( u%YawRate - YawRateCom )                
endif
\end{lstlisting}
CalculateTorque, before each elecpwr calculation
\begin{lstlisting}
if (TrimCase==2) then
    GenTrq = GenTrq + CtrlOffset
endif
\end{lstlisting}
At the end of \tt{Pitch\_CalcOutput}:
\begin{lstlisting}
if (TrimCase==3) then
    y%BlPitchCom  = y%BlPitchCom  + CtrlOffset
endif
\end{lstlisting}
% 




% --------------------------------------------------------------------------------}
% --- BIBLIO 
% --------------------------------------------------------------------------------{
%\bibliographystyle{unsrt}
%\bibliography{Bibliography}

\end{document}
